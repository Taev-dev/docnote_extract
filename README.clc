> docnote_extract
description: 'The build-time companion package to docnote'
<

> Quickstart
__embed__: 'code/python'
    from docnote_extract import gather

    # Replace with whatever package(s) you want to document
    gather(['finnr'])




> Limitations
    ++  namespace packages not supported. you must include ``__init__.py``.
        this is an upstream requirement from cpython itself.
    ++  due to the stubbing strategy, star imports (which you shouldn't be
        using anyways) are fragile, and only work at all in the following
        two situations:
        ++  they're an intra-package import -- ie, not from a third-party
            package -- and the source module defines an ``__all__``
        ++  they're from a third-party package with stubbing disabled
    ++  generally speaking, re-exports must be added to the re-exporting
        module's ``__all__`` for it to be included in documentation


> Core assumptions
    ++  Third-party and intra-package dependencies are always imported from
        their canonical source module.
        ++  For intra-package dependencies, how this looks in documentation
            can be changed via docnote configs -- this allows you, for example,
            to re-export members of private submodules under a public API.
            However, all of your internal imports should point to the same
            location: the module where the dependency was originally defined.
            Failure to do so can cause issues with determining the canonical
            source, resulting in broken intra-module documentation links.
        ++  For third-party dependencies, the rule is: first and foremost,
            always import the same object from the same location, but second,
            import it from the "most proper" location, as according to that
            dependency's docs. Failure to be consistent can result in problems
            determining the canonical source of objects within your docs and
            inconsistent types; failure to import from "most proper" locations
            can break any automatically-generated links to their documentation.


> Thoughts: docnote_extract
    Very first thing:
    ++  install the importhook

    I think I just want this to build a document tree. Not even have any
    templates for cleancopy generation, literally just build the document
    tree. except it also needs to have a dependency tree, I suppose...
    ++  figure out all of the modules in the package to extract, public or
        private, doesn't matter
        ++  first import all of them, traversing down into subpackages
        ++  for every import, create a stringified proxy version of that
            object, which captures the name of the module it's imported in
            and the name of the object in that module (note that this might
            be different from the name within the module-being-processed,
            since it might be imported ``as`` something
        ++  then, iterate over the module's entire ``__dict__`` (don't forget
            to get type hints on it, and don't forget ``include_extras``).
            for every value there:
            ++  check to see if it was defined within that module, or for
                an ``include_in_docs`` override, or if it's in ``__all__``
            ++  if any of the above, include it in the "this is a member of
                this module" set
        ++  make sure you're holding on to the result of ``get_type_hints``
            and that it's preserving all of your proxy versions of everything
            that the module imports
    ++  preserve a stringified version of the globals of every module within
        the resulting module summary object; this will help you automatically
        link any ``code fenced`` objects based on the actual names in the
        namespace, instead of needing a special linking syntax
    ++  once you've done that with every single module, start to fixup any
        intra-package references, replacing proxies to things that are defined
        with links and/or references to the actual object
    ++  your end goal is a tree of every module and submodule, along with
        all of the names in that module that should be included in the docs,
        and every piece of documentation associated with each of those names

    Other thoughts:
    ++  need to always merge the runtime situation (``__dir__``, inspect, etc)
        vs the type hints
    ++  will probably want to have something detecting class, function, coro,
        variable, etc
        ++  each of these should probably have its own node type in the
            final tree


> Thoughts: docs generation package
    then, cleandocs can be responsible for all the rest.

    side note, maybe another name?
    ++  the problem is I want it clearer that it can be used not just for
        docs, but also eg static site generation
    ++  cleancopy_docsgen -- still too doxy
        
    anyways, the idea would be:
    ++  use templatey to generate temporary (maybe purely inmemory) cleancopy
        docs, as a peer for the hand-written static/companion docs
    ++  parse those using cleancopy, along with all static/companion docs,
        into a docset
    ++  have an AST transforming function that converts that into a template
        instance tree, which can be inserted anywhere into a parent template
        ++  the biggest question here is navigation
        ++  I think probably you should have a sequence of ``Page`` objects,
            and each page object is a container, NOT a template instance
        ++  local navigation would be built based on the list of all of the
            pages, so that would be orthogonal, you just need to make sure
            you have the actual page objects. so that makes sense
        ++  you'd need to have a ``make_link`` env function, so that the
            template hyperlinks work



> Contributing

    TODO: proper contributing guide.

    Things to remember in the meantime:
    ++  we use conftest.py strictly for pytest customization. Fixtures etc
        should be put into ``docnote_extract_testutils`` within ``sidecars_py``.
